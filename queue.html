<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Queue</title>
</head>
<body>
<script>
    /** 42  用索引优先队列存放height,大的先出,维护一个范围。每次范围扩展,alive减去扩展掉的元素个数
     * @param {number[]} height
     * @return {number}
     */
    function QueueIndex(list) {
        this.list = [];
        this.values = list;
        list.forEach((a, i)=>this.push(i));
    }
    QueueIndex.prototype.push = function (idx) {
        this.list.push(idx);
        for (let i = this.list.length - 1; i > 0; i--) {
            if (this.values[this.list[i]] > this.values[this.list[i - 1]]) {
                [this.list[i - 1], this.list[i]] = [this.list[i], this.list[i - 1]];
            } else {
                break;
            }
        }
    };
    QueueIndex.prototype.pop = function () {
        return this.list.shift();
    };
    var trap = function (height) {
        if (height.length < 2) {
            return 0;
        }
        let ret = 0;
        const queue = new QueueIndex(height);
        const boundary = queue.pop();
        let [left , right] =[boundary, boundary];
        let alive = queue.size();
        while (alive) {
            const site = queue.pop();
            if (site > left && site < right) {
                continue;
            } else {
                if (site < left) {
                    for (let i = site + 1, limit = height[site]; i < left; i++) {
                        ret += limit - height[i];
                    }
                    alive -= left -site;
                    left = site;
                }
                if (site > right) {
                    for (let i = right + 1, limit = height[site]; i < site; i++) {
                        ret += limit - height[i];
                    }
                    alive -= site -right;
                    right = site;
                }
            }
        }
        return ret;
    };

//    console.log(trap([5, 2, 1, 2, 1, 5]));
//    console.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]));
    /** 767
     * @param {string} S
     * @return {string}
     */
    var reorganizeString = function (S) {
        const queue = new MyQueue(Array.from(S));
        let ret = '', cur = 'null';
        if (!S.length || queue.peek().value > Math.ceil(S.length / 2)) {
            return '';
        }
        while (queue.peek() && (queue.peek().value > 1 || queue.peek().key == cur)) {
            const {key, idx} = queue.sort(cur);
            queue.decrease(idx);
            cur = key;
            ret += cur;
        }
        return ret + queue.stringfy();
    };
    function MyQueue(list) {
        this.list = [];
        list.forEach(a=>this.push(a));
    }
    MyQueue.prototype.push = function (char) {
        const idx = this.list.findIndex(a=>a.key == char);
        if (idx == -1) {
            this.list.push({key: char, value: 1});
        } else {
            this.list[idx].value++;
            this.refreshInc(idx);
        }
    };
    MyQueue.prototype.peek = function () {
        return this.list[0];
    };
    MyQueue.prototype.refreshInc = function (idx) {
        while (idx > 0) {
            if (this.list[idx].value > this.list[idx - 1].value) {
                [this.list[idx - 1].value, this.list[idx].value] = [this.list[idx].value, this.list[idx - 1].value];
                [this.list[idx - 1].key, this.list[idx].key] = [this.list[idx].key, this.list[idx - 1].key];
                idx--;
            } else {
                break;
            }
        }
    };
    MyQueue.prototype.sort = function (char) {
        let idx = this.list.findIndex(a=> a.key != char);
        idx = idx == -1 ? 0 : idx;
        return Object.assign(this.list[idx], {idx: idx});
    };
    MyQueue.prototype.decrease = function (idx) {
        if (this.list[idx].value > 1) {
            this.list[idx].value--;
            this.refreshDec(idx);
        } else {
            this.list.splice(idx, 1);
        }
    };
    MyQueue.prototype.refreshDec = function (idx) {
        while (idx < this.list.length - 1) {
            if (this.list[idx].value < this.list[idx + 1].value) {
                [this.list[idx + 1].value, this.list[idx].value] = [this.list[idx].value, this.list[idx + 1].value];
                [this.list[idx + 1].key, this.list[idx].key] = [this.list[idx].key, this.list[idx + 1].key];
                idx++;
            } else {
                break;
            }
        }
    };
    MyQueue.prototype.stringfy = function () {
        return this.list.map(a=>a.key).join('');
    };
    //    console.log(reorganizeString('aaab'));
    //    console.log(reorganizeString("eqmeyggvp"));
    //    console.log(reorganizeString("abbabbaaab"));
</script>
</body>
</html>